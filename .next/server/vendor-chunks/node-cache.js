/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-cache";
exports.ids = ["vendor-chunks/node-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-cache/index.js":
/*!******************************************!*\
  !*** ./node_modules/node-cache/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var exports;\n\n  exports = module.exports = __webpack_require__(/*! ./lib/node_cache */ \"(rsc)/./node_modules/node-cache/lib/node_cache.js\");\n\n  exports.version = '5.1.2';\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUhBQTRDOztBQUV4RDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy8uL25vZGVfbW9kdWxlcy9ub2RlLWNhY2hlL2luZGV4LmpzP2UzNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIG5vZGUtY2FjaGUgNS4xLjIgKCAyMDIwLTA3LTAxIClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGVcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1haW50YWluZWQgYnkgICggIClcbiovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBleHBvcnRzO1xuXG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL25vZGVfY2FjaGUnKTtcblxuICBleHBvcnRzLnZlcnNpb24gPSAnNS4xLjInO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-cache/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/node-cache/lib/node_cache.js":
/*!***************************************************!*\
  !*** ./node_modules/node-cache/lib/node_cache.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = __webpack_require__(/*! clone */ \"(rsc)/./node_modules/clone/clone.js\");\n\n  EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9saWIvbm9kZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDLHFFQUFxRTtBQUN4Szs7QUFFQSxVQUFVLG1CQUFPLENBQUMsa0RBQU87O0FBRXpCLGlCQUFpQiwwREFBOEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy8uL25vZGVfbW9kdWxlcy9ub2RlLWNhY2hlL2xpYi9ub2RlX2NhY2hlLmpzP2RhODUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIG5vZGUtY2FjaGUgNS4xLjIgKCAyMDIwLTA3LTAxIClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGVcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWNhY2hlL25vZGUtY2FjaGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIE1haW50YWluZWQgYnkgICggIClcbiovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBFdmVudEVtaXR0ZXIsIE5vZGVDYWNoZSwgY2xvbmUsXG4gICAgc3BsaWNlID0gW10uc3BsaWNlLFxuICAgIGJvdW5kTWV0aG9kQ2hlY2sgPSBmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IEVycm9yKCdCb3VuZCBpbnN0YW5jZSBtZXRob2QgYWNjZXNzZWQgYmVmb3JlIGJpbmRpbmcnKTsgfSB9LFxuICAgIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG4gIGNsb25lID0gcmVxdWlyZShcImNsb25lXCIpO1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuICAvLyBnZW5lcmF0ZSBzdXBlcmNsYXNzXG4gIG1vZHVsZS5leHBvcnRzID0gTm9kZUNhY2hlID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIE5vZGVDYWNoZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gIyMgZ2V0XG5cbiAgICAgICAgLy8gZ2V0IGEgY2FjaGVkIGtleSBhbmQgY2hhbmdlIHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5XG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuZ2V0IFwibXlLZXlcIiwgKCBlcnIsIHZhbCApXG5cbiAgICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBtZ2V0XG5cbiAgICAgICAgLy8gZ2V0IG11bHRpcGxlIGNhY2hlZCBrZXlzIGF0IG9uY2UgYW5kIGNoYW5nZSB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlzYCAoIFN0cmluZ3xOdW1iZXJbXSApOiBhbiBhcnJheSBvZiBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUubWdldCBbIFwiZm9vXCIsIFwiYmFyXCIgXVxuXG4gICAgICAgIHRoaXMubWdldCA9IHRoaXMubWdldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBzZXRcblxuICAgICAgICAvLyBzZXQgYSBjYWNoZWQga2V5IGFuZCBjaGFuZ2UgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcbiAgICAgICAgLy8gKiBgdmFsdWVgICggQW55ICk6IEEgZWxlbWVudCB0byBjYWNoZS4gSWYgdGhlIG9wdGlvbiBgb3B0aW9uLmZvcmNlU3RyaW5nYCBpcyBgdHJ1ZWAgdGhlIG1vZHVsZSB0cnlzIHRvIHRyYW5zbGF0ZSBpdCB0byBhIHNlcmlhbGl6ZWQgSlNPTlxuICAgICAgICAvLyAqIGBbIHR0bCBdYCAoIE51bWJlciB8IFN0cmluZyApOiAoIG9wdGlvbmFsICkgVGhlIHRpbWUgdG8gbGl2ZSBpbiBzZWNvbmRzLlxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnNldCBcIm15S2V5XCIsIFwibXlfU3RyaW5nIFZhbHVlXCJcblxuICAgICAgICAvL1x0bXlDYWNoZS5zZXQgXCJteUtleVwiLCBcIm15X1N0cmluZyBWYWx1ZVwiLCAxMFxuXG4gICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vICMjIG1zZXRcblxuICAgICAgICAvLyBzZXQgbXVsdGlwbGUga2V5cyBhdCBvbmNlXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5VmFsdWVTZXRgICggT2JqZWN0W10gKTogYW4gYXJyYXkgb2Ygb2JqZWN0IHdoaWNoIGluY2x1ZGVzIGtleSx2YWx1ZSBhbmQgdHRsXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUubXNldChcbiAgICAgICAgLy9cdFx0W1xuICAgICAgICAvL1x0XHRcdHtcbiAgICAgICAgLy9cdFx0XHRcdGtleTogXCJteUtleVwiLFxuICAgICAgICAvL1x0XHRcdFx0dmFsOiBcIm15VmFsdWVcIixcbiAgICAgICAgLy9cdFx0XHRcdHR0bDogW3R0bCBpbiBzZWNvbmRzXVxuICAgICAgICAvL1x0XHRcdH1cbiAgICAgICAgLy9cdFx0XSlcblxuICAgICAgICB0aGlzLm1zZXQgPSB0aGlzLm1zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZGVsXG5cbiAgICAgICAgLy8gcmVtb3ZlIGtleXNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlzYCAoIFN0cmluZyB8wqBOdW1iZXIgfCBTdHJpbmd8TnVtYmVyW10gKTogY2FjaGUga2V5IHRvIGRlbGV0ZSBvciBhIGFycmF5IG9mIGNhY2hlIGtleXNcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBOdW1iZXIgKTogTnVtYmVyIG9mIGRlbGV0ZWQga2V5c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLmRlbCggXCJteUtleVwiIClcblxuICAgICAgICB0aGlzLmRlbCA9IHRoaXMuZGVsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHRha2VcblxuICAgICAgICAvLyBnZXQgdGhlIGNhY2hlZCB2YWx1ZSBhbmQgcmVtb3ZlIHRoZSBrZXkgZnJvbSB0aGUgY2FjaGUuXG4gICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgZ2V0KGtleSlgICsgYGRlbChrZXkpYC5cbiAgICAgICAgLy8gVXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgYHNpbmdsZSB1c2VgIG1lY2hhbmlzbSBzdWNoIGFzIE9UUCwgd2hlcmUgb25jZSBhIHZhbHVlIGlzIHJlYWQgaXQgd2lsbCBiZWNvbWUgb2Jzb2xldGUuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS50YWtlIFwibXlLZXlcIiwgKCBlcnIsIHZhbCApXG5cbiAgICAgICAgdGhpcy50YWtlID0gdGhpcy50YWtlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHR0bFxuXG4gICAgICAgIC8vIHJlc2V0IG9yIHJlZGVmaW5lIHRoZSB0dGwgb2YgYSBrZXkuIGB0dGxgID0gMCBtZWFucyBpbmZpbml0ZSBsaWZldGltZS5cbiAgICAgICAgLy8gSWYgYHR0bGAgaXMgbm90IHBhc3NlZCB0aGUgZGVmYXVsdCB0dGwgaXMgdXNlZC5cbiAgICAgICAgLy8gSWYgYHR0bGAgPCAwIHRoZSBrZXkgd2lsbCBiZSBkZWxldGVkLlxuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleWAgKCBTdHJpbmcgfCBOdW1iZXIgKTogY2FjaGUga2V5IHRvIHJlc2V0IHRoZSB0dGwgdmFsdWVcbiAgICAgICAgLy8gKiBgdHRsYCAoIE51bWJlciApOiAoIG9wdGlvbmFsIC0+IG9wdGlvbnMuc3RkVFRMIHx8IDAgKSBUaGUgdGltZSB0byBsaXZlIGluIHNlY29uZHNcblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBCb29sZW4gKToga2V5IGZvdW5kIGFuZCB0dGwgc2V0XG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUudHRsKCBcIm15S2V5XCIgKSAvLyB3aWxsIHNldCB0dGwgdG8gZGVmYXVsdCB0dGxcblxuICAgICAgICAvL1x0bXlDYWNoZS50dGwoIFwibXlLZXlcIiwgMTAwMCApXG5cbiAgICAgICAgdGhpcy50dGwgPSB0aGlzLnR0bC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBnZXRUdGxcblxuICAgICAgICAvLyByZWNlaXZlIHRoZSB0dGwgb2YgYSBrZXkuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gY2hlY2sgdGhlIHR0bCB2YWx1ZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE51bWJlcnx1bmRlZmluZWQgKTogVGhlIHRpbWVzdGFtcCBpbiBtcyB3aGVuIHRoZSBrZXkgd2lsbCBleHBpcmUsIDAgaWYgaXQgd2lsbCBuZXZlciBleHBpcmUgb3IgdW5kZWZpbmVkIGlmIGl0IG5vdCBleGlzdHNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5nZXRUdGwoIFwibXlLZXlcIiApXG5cbiAgICAgICAgdGhpcy5nZXRUdGwgPSB0aGlzLmdldFR0bC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBrZXlzXG5cbiAgICAgICAgLy8gbGlzdCBhbGwga2V5cyB3aXRoaW4gdGhpcyBjYWNoZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEFycmF5ICk6IEFuIGFycmF5IG9mIGFsbCBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIF9rZXlzID0gbXlDYWNoZS5rZXlzKClcblxuICAgICAgICAvLyAgICAgIyBbIFwiZm9vXCIsIFwiYmFyXCIsIFwiZml6elwiLCBcImJ1enpcIiwgXCJhbm90aGVyS2V5c1wiIF1cblxuICAgICAgICB0aGlzLmtleXMgPSB0aGlzLmtleXMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgaGFzXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBrZXkgaXMgY2FjaGVkXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gY2hlY2sgdGhlIHR0bCB2YWx1ZVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEJvb2xlYW4gKTogQSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIGlmIHRoZSBrZXkgaXMgY2FjaGVkXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIF9leGlzdHMgPSBteUNhY2hlLmhhcygnbXlLZXknKVxuXG4gICAgICAgIC8vICAgICAjIHRydWVcblxuICAgICAgICB0aGlzLmhhcyA9IHRoaXMuaGFzLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGdldFN0YXRzXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vIC1cblxuICAgICAgICAvLyAqKlJldHVybioqXG5cbiAgICAgICAgLy8gKCBPYmplY3QgKTogU3RhdHMgZGF0YVxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmdldFN0YXRzKClcbiAgICAgICAgLy8gICAgICMge1xuICAgICAgICAvLyAgICAgIyBoaXRzOiAwLFxuICAgICAgICAvLyAgICAgIyBtaXNzZXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtleXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtzaXplOiAwLFxuICAgICAgICAvLyAgICAgIyB2c2l6ZTogMFxuICAgICAgICAvLyAgICAgIyB9XG5cbiAgICAgICAgdGhpcy5nZXRTdGF0cyA9IHRoaXMuZ2V0U3RhdHMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZmx1c2hBbGxcblxuICAgICAgICAvLyBmbHVzaCB0aGUgd2hvbGUgZGF0YSBhbmQgcmVzZXQgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZmx1c2hBbGwoKVxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmdldFN0YXRzKClcbiAgICAgICAgLy8gICAgICMge1xuICAgICAgICAvLyAgICAgIyBoaXRzOiAwLFxuICAgICAgICAvLyAgICAgIyBtaXNzZXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtleXM6IDAsXG4gICAgICAgIC8vICAgICAjIGtzaXplOiAwLFxuICAgICAgICAvLyAgICAgIyB2c2l6ZTogMFxuICAgICAgICAvLyAgICAgIyB9XG5cbiAgICAgICAgdGhpcy5mbHVzaEFsbCA9IHRoaXMuZmx1c2hBbGwuYmluZCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIC8vICMjIGZsdXNoU3RhdHNcblxuICAgICAgICAvLyBmbHVzaCB0aGUgc3RhdHMgYW5kIHJlc2V0IGFsbCBjb3VudGVycyB0byAwXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZmx1c2hTdGF0cygpXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmZsdXNoU3RhdHMgPSB0aGlzLmZsdXNoU3RhdHMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgY2xvc2VcblxuICAgICAgICAvLyBUaGlzIHdpbGwgY2xlYXIgdGhlIGludGVydmFsIHRpbWVvdXQgd2hpY2ggaXMgc2V0IG9uIGNoZWNrcGVyaW9kIG9wdGlvbi5cblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5jbG9zZSgpXG5cbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2NoZWNrRGF0YVxuXG4gICAgICAgIC8vIGludGVybmFsIGhvdXNla2VlcGluZyBtZXRob2QuXG4gICAgICAgIC8vIENoZWNrIGFsbCB0aGUgY2FjaGVkIGRhdGEgYW5kIGRlbGV0ZSB0aGUgaW52YWxpZCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fY2hlY2tEYXRhID0gdGhpcy5fY2hlY2tEYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9jaGVja1xuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0aGUgY2hlY2sgdGhlIHZhbHVlLiBJZiBpdCdzIG5vdCB2YWxpZCBhbnkgbW9yZSBkZWxldGUgaXRcbiAgICAgICAgdGhpcy5fY2hlY2sgPSB0aGlzLl9jaGVjay5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfaXNJbnZhbGlkS2V5XG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGNoZWNrIGlmIHRoZSB0eXBlIG9mIGEga2V5IGlzIGVpdGhlciBgbnVtYmVyYCBvciBgc3RyaW5nYFxuICAgICAgICB0aGlzLl9pc0ludmFsaWRLZXkgPSB0aGlzLl9pc0ludmFsaWRLZXkuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX3dyYXBcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gd3JhcCBhIHZhbHVlIGluIGFuIG9iamVjdCB3aXRoIHNvbWUgbWV0YWRhdGFcbiAgICAgICAgdGhpcy5fd3JhcCA9IHRoaXMuX3dyYXAuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2dldFZhbExlbmd0aFxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBjYWxjdWxhdGUgdGhlIHZhbHVlIGxlbmd0aFxuICAgICAgICB0aGlzLl9nZXRWYWxMZW5ndGggPSB0aGlzLl9nZXRWYWxMZW5ndGguYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2Vycm9yXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGhhbmRsZSBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgIHRoaXMuX2Vycm9yID0gdGhpcy5fZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2luaXRFcnJvcnNcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gZ2VuZXJhdGUgZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZXNcbiAgICAgICAgdGhpcy5faW5pdEVycm9ycyA9IHRoaXMuX2luaXRFcnJvcnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5faW5pdEVycm9ycygpO1xuICAgICAgICAvLyBjb250YWluZXIgZm9yIGNhY2hlZCBkYXRhXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvLyBtb2R1bGUgb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAvLyBjb252ZXJ0IGFsbCBlbGVtZW50cyB0byBzdHJpbmdcbiAgICAgICAgICBmb3JjZVN0cmluZzogZmFsc2UsXG4gICAgICAgICAgLy8gdXNlZCBzdGFuZGFyZCBzaXplIGZvciBjYWxjdWxhdGluZyB2YWx1ZSBzaXplXG4gICAgICAgICAgb2JqZWN0VmFsdWVTaXplOiA4MCxcbiAgICAgICAgICBwcm9taXNlVmFsdWVTaXplOiA4MCxcbiAgICAgICAgICBhcnJheVZhbHVlU2l6ZTogNDAsXG4gICAgICAgICAgLy8gc3RhbmRhcmQgdGltZSB0byBsaXZlIGluIHNlY29uZHMuIDAgPSBpbmZpbml0eTtcbiAgICAgICAgICBzdGRUVEw6IDAsXG4gICAgICAgICAgLy8gdGltZSBpbiBzZWNvbmRzIHRvIGNoZWNrIGFsbCBkYXRhIGFuZCBkZWxldGUgZXhwaXJlZCBrZXlzXG4gICAgICAgICAgY2hlY2twZXJpb2Q6IDYwMCxcbiAgICAgICAgICAvLyBlbi9kaXNhYmxlIGNsb25pbmcgb2YgdmFyaWFibGVzLiBJZiBgdHJ1ZWAgeW91J2xsIGdldCBhIGNvcHkgb2YgdGhlIGNhY2hlZCB2YXJpYWJsZS4gSWYgYGZhbHNlYCB5b3UnbGwgc2F2ZSBhbmQgZ2V0IGp1c3QgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgIHVzZUNsb25lczogdHJ1ZSxcbiAgICAgICAgICAvLyB3aGV0aGVyIHZhbHVlcyBzaG91bGQgYmUgZGVsZXRlZCBhdXRvbWF0aWNhbGx5IGF0IGV4cGlyYXRpb25cbiAgICAgICAgICBkZWxldGVPbkV4cGlyZTogdHJ1ZSxcbiAgICAgICAgICAvLyBlbmFibGUgbGVnYWN5IGNhbGxiYWNrc1xuICAgICAgICAgIGVuYWJsZUxlZ2FjeUNhbGxiYWNrczogZmFsc2UsXG4gICAgICAgICAgLy8gbWF4IGFtb3VudCBvZiBrZXlzIHRoYXQgYXJlIGJlaW5nIHN0b3JlZFxuICAgICAgICAgIG1heEtleXM6IC0xXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIC8vIGdlbmVyYXRlIGZ1bmN0aW9ucyB3aXRoIGNhbGxiYWNrcyAobGVnYWN5KVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUxlZ2FjeUNhbGxiYWNrcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkchIG5vZGUtY2FjaGUgbGVnYWN5IGNhbGxiYWNrIHN1cHBvcnQgd2lsbCBkcm9wIGluIHY2LnhcIik7XG4gICAgICAgICAgW1wiZ2V0XCIsIFwibWdldFwiLCBcInNldFwiLCBcImRlbFwiLCBcInR0bFwiLCBcImdldFR0bFwiLCBcImtleXNcIiwgXCJoYXNcIl0uZm9yRWFjaCgobWV0aG9kS2V5KSA9PiB7XG4gICAgICAgICAgICB2YXIgb2xkTWV0aG9kO1xuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIHJlYWwgZnVuY3Rpb25cbiAgICAgICAgICAgIG9sZE1ldGhvZCA9IHRoaXNbbWV0aG9kS2V5XTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kS2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGNiLCBlcnIsIHJlZiwgcmVzO1xuICAgICAgICAgICAgICByZWYgPSBhcmdzLCBbLi4uYXJnc10gPSByZWYsIFtjYl0gPSBzcGxpY2UuY2FsbChhcmdzLCAtMSk7XG4gICAgICAgICAgICAgIC8vIHJldHVybiBhIGNhbGxiYWNrIGlmIGNiIGlzIGRlZmluZWQgYW5kIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHJlcyA9IG9sZE1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcjE7XG4gICAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkTWV0aG9kKC4uLmFyZ3MsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGF0aXN0aWNzIGNvbnRhaW5lclxuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgbWlzc2VzOiAwLFxuICAgICAgICAgIGtleXM6IDAsXG4gICAgICAgICAga3NpemU6IDAsXG4gICAgICAgICAgdnNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcHJlIGFsbG9jYXRlIHZhbGlkIGtleXR5cGVzIGFycmF5XG4gICAgICAgIHRoaXMudmFsaWRLZXlUeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiXTtcbiAgICAgICAgLy8gaW5pdGFsaXplIGNoZWNraW5nIHBlcmlvZFxuICAgICAgICB0aGlzLl9jaGVja0RhdGEoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBfcmV0LCBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGRhdGEgYW5kIGluY3JlbWV0IHN0YXRzXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmhpdHMrKztcbiAgICAgICAgICBfcmV0ID0gdGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgICAvLyByZXR1cm4gZGF0YVxuICAgICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIG5vdCBmb3VuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgdGhpcy5zdGF0cy5taXNzZXMrKztcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1nZXQoa2V5cykge1xuICAgICAgICB2YXIgX2VyciwgZXJyLCBpLCBrZXksIGxlbiwgb1JldDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjb252ZXJ0IGEgc3RyaW5nIHRvIGFuIGFycmF5IG9mIG9uZSBrZXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUtFWVNUWVBFXCIpO1xuICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHJldHVyblxuICAgICAgICBvUmV0ID0ge307XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZ2V0IGRhdGEgYW5kIGluY3JlbWVudCBzdGF0c1xuICAgICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMuaGl0cysrO1xuICAgICAgICAgICAgb1JldFtrZXldID0gdGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm90IGZvdW5kIHJldHVybiBhIGVycm9yXG4gICAgICAgICAgICB0aGlzLnN0YXRzLm1pc3NlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gYWxsIGZvdW5kIGtleXNcbiAgICAgICAgcmV0dXJuIG9SZXQ7XG4gICAgICB9XG5cbiAgICAgIHNldChrZXksIHZhbHVlLCB0dGwpIHtcbiAgICAgICAgdmFyIF9lcnIsIGVyciwgZXhpc3RlbnQ7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgb3ZlcmZsb3dpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhLZXlzID4gLTEgJiYgdGhpcy5zdGF0cy5rZXlzID49IHRoaXMub3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUNBQ0hFRlVMTFwiKTtcbiAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcmNlIHRoZSBkYXRhIHRvIHN0cmluZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlU3RyaW5nICYmICF0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgZGVmYXVsdCB0dGwgaWYgbm90IHBhc3NlZFxuICAgICAgICBpZiAodHRsID09IG51bGwpIHtcbiAgICAgICAgICB0dGwgPSB0aGlzLm9wdGlvbnMuc3RkVFRMO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVybmFsIGhlbHBlciB2YXJpYWJsZXNcbiAgICAgICAgZXhpc3RlbnQgPSBmYWxzZTtcbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGRhdGEgZnJvbSBzdGF0c1xuICAgICAgICBpZiAodGhpcy5kYXRhW2tleV0pIHtcbiAgICAgICAgICBleGlzdGVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGF0cy52c2l6ZSAtPSB0aGlzLl9nZXRWYWxMZW5ndGgodGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB0aGlzLl93cmFwKHZhbHVlLCB0dGwpO1xuICAgICAgICB0aGlzLnN0YXRzLnZzaXplICs9IHRoaXMuX2dldFZhbExlbmd0aCh2YWx1ZSk7XG4gICAgICAgIC8vIG9ubHkgYWRkIHRoZSBrZXlzIGFuZCBrZXktc2l6ZSBpZiB0aGUga2V5IGlzIG5ld1xuICAgICAgICBpZiAoIWV4aXN0ZW50KSB7XG4gICAgICAgICAgdGhpcy5zdGF0cy5rc2l6ZSArPSB0aGlzLl9nZXRLZXlMZW5ndGgoa2V5KTtcbiAgICAgICAgICB0aGlzLnN0YXRzLmtleXMrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzZXRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBtc2V0KGtleVZhbHVlU2V0KSB7XG4gICAgICAgIHZhciBfZXJyLCBlcnIsIGksIGosIGtleSwga2V5VmFsdWVQYWlyLCBsZW4sIGxlbjEsIHR0bCwgdmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIG92ZXJmbG93aW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4S2V5cyA+IC0xICYmIHRoaXMuc3RhdHMua2V5cyArIGtleVZhbHVlU2V0Lmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4S2V5cykge1xuICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVDQUNIRUZVTExcIik7XG4gICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgfVxuXG4vLyBsb29wIG92ZXIga2V5VmFsdWVTZXQgdG8gdmFsaWRhdGUga2V5IGFuZCB0dGxcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5VmFsdWVTZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXlWYWx1ZVBhaXIgPSBrZXlWYWx1ZVNldFtpXTtcbiAgICAgICAgICAoe2tleSwgdmFsLCB0dGx9ID0ga2V5VmFsdWVQYWlyKTtcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyB0dGwgYW5kIGl0J3MgYSBudW1iZXJcbiAgICAgICAgICBpZiAodHRsICYmIHR5cGVvZiB0dGwgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIF9lcnIgPSB0aGlzLl9lcnJvcihcIkVUVExUWVBFXCIpO1xuICAgICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0ga2V5VmFsdWVTZXQubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAga2V5VmFsdWVQYWlyID0ga2V5VmFsdWVTZXRbal07XG4gICAgICAgICAgKHtrZXksIHZhbCwgdHRsfSA9IGtleVZhbHVlUGFpcik7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWwsIHR0bCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGRlbChrZXlzKSB7XG4gICAgICAgIHZhciBkZWxDb3VudCwgZXJyLCBpLCBrZXksIGxlbiwgb2xkVmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNvbnZlcnQga2V5cyB0byBhbiBhcnJheSBvZiBpdHNlbGZcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAga2V5cyA9IFtrZXlzXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxDb3VudCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb25seSBkZWxldGUgaWYgZXhpc3RlbnRcbiAgICAgICAgICBpZiAodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2FsYyB0aGUgc3RhdHNcbiAgICAgICAgICAgIHRoaXMuc3RhdHMudnNpemUgLT0gdGhpcy5fZ2V0VmFsTGVuZ3RoKHRoaXMuX3Vud3JhcCh0aGlzLmRhdGFba2V5XSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMua3NpemUgLT0gdGhpcy5fZ2V0S2V5TGVuZ3RoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmtleXMtLTtcbiAgICAgICAgICAgIGRlbENvdW50Kys7XG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIHZhbHVlXG4gICAgICAgICAgICBvbGRWYWwgPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgICAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWxcIiwga2V5LCBvbGRWYWwudik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxDb3VudDtcbiAgICAgIH1cblxuICAgICAgdGFrZShrZXkpIHtcbiAgICAgICAgdmFyIF9yZXQ7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX3JldCA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICgoX3JldCAhPSBudWxsKSkge1xuICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICB9XG5cbiAgICAgIHR0bChrZXksIHR0bCkge1xuICAgICAgICB2YXIgZXJyO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHR0bCB8fCAodHRsID0gdGhpcy5vcHRpb25zLnN0ZFRUTCk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGVudCBkYXRhIGFuZCB1cGRhdGUgdGhlIHR0bCB2YWx1ZVxuICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgLy8gaWYgdHRsIDwgMCBkZWxldGUgdGhlIGtleS4gb3RoZXJ3aXNlIHJlc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgIGlmICh0dGwgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB0aGlzLl93cmFwKHRoaXMuZGF0YVtrZXldLnYsIHR0bCwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXR1cm4gZmFsc2UgaWYga2V5IGhhcyBub3QgYmVlbiBmb3VuZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZXRUdGwoa2V5KSB7XG4gICAgICAgIHZhciBfdHRsLCBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBpbnZhbGlkIGtleSB0eXBlc1xuICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBleGlzdGFudCBkYXRhIGFuZCB1cGRhdGUgdGhlIHR0bCB2YWx1ZVxuICAgICAgICBpZiAoKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pKSB7XG4gICAgICAgICAgX3R0bCA9IHRoaXMuZGF0YVtrZXldLnQ7XG4gICAgICAgICAgcmV0dXJuIF90dGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmV0dXJuIHVuZGVmaW5lZCBpZiBrZXkgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBrZXlzKCkge1xuICAgICAgICB2YXIgX2tleXM7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX2tleXMgPSBPYmplY3Qua2V5cyh0aGlzLmRhdGEpO1xuICAgICAgICByZXR1cm4gX2tleXM7XG4gICAgICB9XG5cbiAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIF9leGlzdHM7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgX2V4aXN0cyA9ICh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKTtcbiAgICAgICAgcmV0dXJuIF9leGlzdHM7XG4gICAgICB9XG5cbiAgICAgIGdldFN0YXRzKCkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRzO1xuICAgICAgfVxuXG4gICAgICBmbHVzaEFsbChfc3RhcnRQZXJpb2QgPSB0cnVlKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gcGFyYW1ldGVyIGp1c3QgZm9yIHRlc3RpbmdcblxuICAgICAgICAvLyBzZXQgZGF0YSBlbXB0eVxuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgLy8gcmVzZXQgc3RhdHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICBrZXlzOiAwLFxuICAgICAgICAgIGtzaXplOiAwLFxuICAgICAgICAgIHZzaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlc2V0IGNoZWNrIHBlcmlvZFxuICAgICAgICB0aGlzLl9raWxsQ2hlY2tQZXJpb2QoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tEYXRhKF9zdGFydFBlcmlvZCk7XG4gICAgICAgIHRoaXMuZW1pdChcImZsdXNoXCIpO1xuICAgICAgfVxuXG4gICAgICBmbHVzaFN0YXRzKCkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIHJlc2V0IHN0YXRzXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAga2V5czogMCxcbiAgICAgICAgICBrc2l6ZTogMCxcbiAgICAgICAgICB2c2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJmbHVzaF9zdGF0c1wiKTtcbiAgICAgIH1cblxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdGhpcy5fa2lsbENoZWNrUGVyaW9kKCk7XG4gICAgICB9XG5cbiAgICAgIF9jaGVja0RhdGEoc3RhcnRQZXJpb2QgPSB0cnVlKSB7XG4gICAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgcmVmID0gdGhpcy5kYXRhO1xuICAgICAgICAvLyBydW4gdGhlIGhvdXNla2VlcGluZyBtZXRob2RcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgICB0aGlzLl9jaGVjayhrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRQZXJpb2QgJiYgdGhpcy5vcHRpb25zLmNoZWNrcGVyaW9kID4gMCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9jaGVja0RhdGEsIHRoaXMub3B0aW9ucy5jaGVja3BlcmlvZCAqIDEwMDAsIHN0YXJ0UGVyaW9kKTtcbiAgICAgICAgICBpZiAoKHRoaXMuY2hlY2tUaW1lb3V0ICE9IG51bGwpICYmICh0aGlzLmNoZWNrVGltZW91dC51bnJlZiAhPSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1RpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gIyMgX2tpbGxDaGVja1BlcmlvZFxuXG4gICAgICAvLyBzdG9wIHRoZSBjaGVja2RhdGEgcGVyaW9kLiBPbmx5IG5lZWRlZCB0byBhYm9ydCB0aGUgc2NyaXB0IGluIHRlc3RpbmcgbW9kZS5cbiAgICAgIF9raWxsQ2hlY2tQZXJpb2QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLmNoZWNrVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NoZWNrKGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgX3JldHZhbDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfcmV0dmFsID0gdHJ1ZTtcbiAgICAgICAgLy8gZGF0YSBpcyBpbnZhbGlkIGlmIHRoZSB0dGwgaXMgdG9vIG9sZCBhbmQgaXMgbm90IDBcbiAgICAgICAgLy8gY29uc29sZS5sb2cgZGF0YS50IDwgRGF0ZS5ub3coKSwgZGF0YS50LCBEYXRlLm5vdygpXG4gICAgICAgIGlmIChkYXRhLnQgIT09IDAgJiYgZGF0YS50IDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVsZXRlT25FeHBpcmUpIHtcbiAgICAgICAgICAgIF9yZXR2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChcImV4cGlyZWRcIiwga2V5LCB0aGlzLl91bndyYXAoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmV0dmFsO1xuICAgICAgfVxuXG4gICAgICBfaXNJbnZhbGlkS2V5KGtleSkge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmIChyZWYgPSB0eXBlb2Yga2V5LCBpbmRleE9mLmNhbGwodGhpcy52YWxpZEtleVR5cGVzLCByZWYpIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcihcIkVLRVlUWVBFXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVvZiBrZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfd3JhcCh2YWx1ZSwgdHRsLCBhc0Nsb25lID0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGl2ZXRpbWUsIG5vdywgb1JldHVybiwgdHRsTXVsdGlwbGljYXRvcjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VDbG9uZXMpIHtcbiAgICAgICAgICBhc0Nsb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5lIHRoZSB0aW1lIHRvIGxpdmVcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGl2ZXRpbWUgPSAwO1xuICAgICAgICB0dGxNdWx0aXBsaWNhdG9yID0gMTAwMDtcbiAgICAgICAgLy8gdXNlIGdpdmVuIHR0bFxuICAgICAgICBpZiAodHRsID09PSAwKSB7XG4gICAgICAgICAgbGl2ZXRpbWUgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHR0bCkge1xuICAgICAgICAgIGxpdmV0aW1lID0gbm93ICsgKHR0bCAqIHR0bE11bHRpcGxpY2F0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBzdGFuZGFyZCB0dGxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0ZFRUTCA9PT0gMCkge1xuICAgICAgICAgICAgbGl2ZXRpbWUgPSB0aGlzLm9wdGlvbnMuc3RkVFRMO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXZldGltZSA9IG5vdyArICh0aGlzLm9wdGlvbnMuc3RkVFRMICogdHRsTXVsdGlwbGljYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiB0aGUgd3JhcHBlZCB2YWx1ZVxuICAgICAgICByZXR1cm4gb1JldHVybiA9IHtcbiAgICAgICAgICB0OiBsaXZldGltZSxcbiAgICAgICAgICB2OiBhc0Nsb25lID8gY2xvbmUodmFsdWUpIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gIyMgX3Vud3JhcFxuXG4gICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gZXh0cmFjdCBnZXQgdGhlIHZhbHVlIG91dCBvZiB0aGUgd3JhcHBlZCB2YWx1ZVxuICAgICAgX3Vud3JhcCh2YWx1ZSwgYXNDbG9uZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlQ2xvbmVzKSB7XG4gICAgICAgICAgYXNDbG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS52ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYXNDbG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHZhbHVlLnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vICMjIF9nZXRLZXlMZW5ndGhcblxuICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRoZSBjYWxjdWxhdGUgdGhlIGtleSBsZW5ndGhcbiAgICAgIF9nZXRLZXlMZW5ndGgoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIF9nZXRWYWxMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgU3RyaW5nIGdldCB0aGUgcmVhbCBsZW5ndGhcbiAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVN0cmluZykge1xuICAgICAgICAgIC8vIGZvcmNlIHN0cmluZyBpZiBpdCdzIGRlZmluZWQgYW5kIG5vdCBwYXNzZWRcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIGFuIEFycmF5IG11bHRpcGx5IGVhY2ggZWxlbWVudCB3aXRoIGEgZGVmaW5lZCBkZWZhdWx0IGxlbmd0aFxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXJyYXlWYWx1ZVNpemUgKiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICh2YWx1ZSAhPSBudWxsID8gdmFsdWUudGhlbiA6IHZvaWQgMCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGlzIGEgUHJvbWlzZSwgdXNlIGRlZmluZWQgZGVmYXVsdFxuICAgICAgICAgIC8vIChjYW4ndCBjYWxjdWxhdGUgYWN0dWFsL3Jlc29sdmVkIHZhbHVlIHNpemUgc3luY2hyb25vdXNseSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByb21pc2VWYWx1ZVNpemU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBCdWZmZXIgIT09IG51bGwgPyBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIDogdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICgodmFsdWUgIT0gbnVsbCkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYW4gT2JqZWN0IG11bHRpcGx5IGVhY2ggZWxlbWVudCB3aXRoIGEgZGVmaW5lZCBkZWZhdWx0IGxlbmd0aFxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMub2JqZWN0VmFsdWVTaXplICogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmYXVsdCBmYWxsYmFja1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9lcnJvcih0eXBlLCBkYXRhID0ge30pIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgZXJyb3IubmFtZSA9IHR5cGU7XG4gICAgICAgIGVycm9yLmVycm9yY29kZSA9IHR5cGU7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgPSB0aGlzLkVSUk9SU1t0eXBlXSAhPSBudWxsID8gdGhpcy5FUlJPUlNbdHlwZV0oZGF0YSkgOiBcIi1cIjtcbiAgICAgICAgZXJyb3IuZGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIHJldHVybiB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgX2luaXRFcnJvcnMoKSB7XG4gICAgICAgIHZhciBfZXJyTXNnLCBfZXJyVCwgcmVmO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIHRoaXMuRVJST1JTID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMuX0VSUk9SUztcbiAgICAgICAgZm9yIChfZXJyVCBpbiByZWYpIHtcbiAgICAgICAgICBfZXJyTXNnID0gcmVmW19lcnJUXTtcbiAgICAgICAgICB0aGlzLkVSUk9SU1tfZXJyVF0gPSB0aGlzLmNyZWF0ZUVycm9yTWVzc2FnZShfZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjcmVhdGVFcnJvck1lc3NhZ2UoZXJyTXNnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGVyck1zZy5yZXBsYWNlKFwiX19rZXlcIiwgYXJncy50eXBlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBOb2RlQ2FjaGUucHJvdG90eXBlLl9FUlJPUlMgPSB7XG4gICAgICBcIkVOT1RGT1VORFwiOiBcIktleSBgX19rZXlgIG5vdCBmb3VuZFwiLFxuICAgICAgXCJFQ0FDSEVGVUxMXCI6IFwiQ2FjaGUgbWF4IGtleXMgYW1vdW50IGV4Y2VlZGVkXCIsXG4gICAgICBcIkVLRVlUWVBFXCI6IFwiVGhlIGtleSBhcmd1bWVudCBoYXMgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCBvciBgbnVtYmVyYC4gRm91bmQ6IGBfX2tleWBcIixcbiAgICAgIFwiRUtFWVNUWVBFXCI6IFwiVGhlIGtleXMgYXJndW1lbnQgaGFzIHRvIGJlIGFuIGFycmF5LlwiLFxuICAgICAgXCJFVFRMVFlQRVwiOiBcIlRoZSB0dGwgYXJndW1lbnQgaGFzIHRvIGJlIGEgbnVtYmVyLlwiXG4gICAgfTtcblxuICAgIHJldHVybiBOb2RlQ2FjaGU7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-cache/lib/node_cache.js\n");

/***/ })

};
;